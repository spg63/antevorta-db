Movie DB object:
	budget, numeric value
	Genre --> This should be a pointer to a separate table of genres
		- It is a numeric id and a text name
	homepage, just a text link
	id, numeric value
	keywords --> This should be a pointer to a seaprate table of keywords
		- It is a numeric id and a text name
	original_language (NO)
	original_title, text
	overview, long text
	popularity, floating point score
	production companies --> This should be a pointer to a separate table
		- It is a text name and a numeric id
	production_countries, not sure, maybe. If so, probably a separate table
	release date, currently YYYY-MM-DD, need to turn it into DT
	revenue, long numeric
	runtime, numeric
	spoken_languages, Probably a separate table again
	tagline, text
	status, (mostly) Released, text
	title, the final title, text
	vote_average, floating point out-of-10 rating
	vote_count, numeric total of votes cast

Actor DB object:
	movie_id, numeric id
	title, the final title
	cast, should be a separate table
		- cast_id, numeric
		- character, text
		- credit_id, hexa
		- gender, numeric
		- id, numeric
		- name, text, 
		- order, presumably the credit order in the movie
	crew, should be a separate table
		- Not sure about this stuff, but it's got some good shit that I should probably track, like casting people and production people who obviously have an impact on movie success


---------------------

Ignore the above.

Going to go with a big table that stores the current json in json using the sqlite json1 extension. The data that's in
json format won't need to be indexed like it is for reddit data, it's not really timeseries data and there won't be
selects similar to gathering all from a sub within some date range.

Lists of actors, producers, etc will be put into a json array and stored like that with a movie. No need for a
complicated DB structure here. It's use once for training and forget, the performance at this level will be *way*
overshadowed by the slowness at the training level.

NOTE: This is, of course, not the most efficient solution. It is, however, the best solution from a development time
standpoint -- a different kind of efficiency.